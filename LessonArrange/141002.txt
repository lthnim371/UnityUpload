Question
애니메이션간의 연결 가능 유무

처음 부분 복습 필요함(약 10분 지각함)

샌드메시지
직접 호출보다는 비용이 드므로 매 프레임마다 사용하면 부담스럽다. 그러므로 가끔씩 사용될 때는 괜찮다.
접근제한자를 가리지 않는다. private도 실행시킴

애니메이션에 이벤트를 넣으면 원본 클립에 넣어지기 때문에 해당 애니메이션을 사용하는
오브젝트 혹은 스크립트를 가진 오브젝트들에게 자동으로 호출해준다.(메시지를 던져준다라고 보면 된다)
※ c#은 기본 함수들를 c++ 코어에서 이름으로 찾아서 호출시키는 구조이다.

샌드메시지 사용 예 : 해당 게임오브젝트가 자주 바뀌는 경우라면...

애니메이션과 관련된 샌드메시지에 대해...(5:19 참고)

컬링타입 (5:24 참고)
Always Animate : 카메라 시야 밖에 있어도 행렬 업데이트를 한다.
Based On Render : 카메라 시야 밖에 있으면 시간은 그대로 흘러가나 행렬 업데이트를 안한다...
그래서 Based On Render은 샌드 관련 함수 호출이 일어나지 않는다.(다시 보일 때쯤 한꺼번에 발생됨)
그러므로 별로 중요치 않은 상황일 때는 Based On Render로 처리하고
중요한 이벤트 발생이 필요하다면 Always Animate로 설정을 바꿔줄 필요성이 있다.
즉, 코드로 제어가능하다.

샌드클립에 AddEvent하는 것은 원본 클립에 추가하는 것이기 때문에 만약 같은 클래스를 사용하는
오브젝트들이 여러개라면 중복 적용되어 그만큼 중복 호출이 되버린다...그러므로 한번만 적용되게끔 해야함

타격 설정 방법(5:43 참고 - 이론)
레이 이용
콜리더 이용


4.
캐릭터컨트롤러는 강체가 아니다...자체 컬리더 기능은 있으나 리지드바디 기능은 없다.
그러나 물리적인 영향을 아예 안 받는건 아니다...(그래서 되도록 픽시드업데이트에서 코드 작성)

스페셜포스 문제처럼 캐릭터의 대각선 이동이 빠른거에 대해...(6:17 참고) -> 확인완료
x, z값이 동시에 적용되면 그만큼 값이 쌓여 더 빨라지게 되는 문제가 발생한다..
그래서 노말라이즈 하여 값을 정규화시키면 되기는 한데
만약 미세한 컨트롤에 의해 값이 살짝만 들어와도 더 큰 값인 1로 정규화되므로 문제가 된다.
그러므로 입력벡터의 길이가 1 이상일 경우에만 정규화를 한다..
이 때, 길이를 구하는 함수는 magnitude 보다 sqrMagnitude로 하는 것이 비용이 덜 든다.
(제곱으로 구하는데 1 이하는 값이 더 작아지고 1은 그대로 1이기 때문에 1 이상인지 파악이 가능하다)

캐릭터컨트롤러는 이동만 자체 Move 함수로 해야 되지만 회전은 트랜스폼으로 하여도 괜찮다.

함수를 이용하여 마우스 변위량을 구할 때 Time.deltaTime으로 곱해주면 안된다.

p158, 160 참고
step offset 의 주목적
계단보다는 터레인의 살짝 튀어나온 돌멩이같이 터레인 오브젝트 디자인이 살짝 올라간 바람에
거기에 걸려서 이동이 안 되는것을 방지하고자 주로 사용

skin width의 필요성
캐릭터 간에 서로 움직여서 서로 끼게 될 경우를 대비.

min move distance : 이동 벡터의 길이가 이 값이 설정한 값의 최소 값 이상으로 들어와야 이동함

※ 스탠다드 에셋의 컨트롤러에 붙어 있는 CharacterMotor코드는 자바스크립트로 되어 있기 때문에..
만약 분석하고 싶다면 구글링ㅋ
CharacterMotor코드는 매우 쓸만하다. -p161참고



숙제
1. 진삼국무쌍처럼 만들기
캐릭터 이동은 택일 - 직접 만들거나 CharacterMotor코드 분석해서 사용

도전과제
마우스 휠 줌아웃에 따라 확대축소

도전과제
죽을때 랙돌 넣기
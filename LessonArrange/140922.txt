//this.transform
//this.GetComponent<Transform>();
//위의 방식들은 무겁지는 않으나 c#과 c++(유니티 핵심코어)간의 통신 및 검색 등으로 인해 그래도 시간이 걸리기는 한다..
그래서 조금이라도 빠르게 하기 위해 아래와 같이 미리 참조시켜놓는다.
this._transform = this.transform;
this._rigidbody = this.rigidbody;

모든 물리 업데이트는 픽시드업데이트에서 하시오

velocity
월드 기준의 초당 움직임 다 0이 되면 움직임이 멈추었다 라는걸 의미
벨로시티는 중력의 제한을 받음(만약 중력의 영향을 받는다면)

리지드바디가 붙어 있는 것의 트랜스폼을 건드리면 그 변한 수치만큼에 따른 벨로시티 값을
역으로 계산하여 구하기 때문에 엄청 무거워진다.
그러므로 리지드바디가 붙었을 때는 트랜스폼에 직접 변화를 주지 말아라

만약 Instantiate로 인한 생성이 아닌 풀링으로 오브젝트를 사용할 시
벨로시티 값이 계속 누적이 된 상태에서 급 비활성화되면
다시 활성화하였을때 그 값을 이어서 적용되기때문에 원치 않는 결과가 발생한다.
그러므로 OnDisable() 에서 벨로시티를 다시 초기화해주는 것이 좋다.


1. AddForce, AddTorque 사용법 및 ForceMode 종류

2. AddForce, AddTorque을 활용하여 피해 데미지 파티클 표현하기
추후에 주사위로 응용 가능